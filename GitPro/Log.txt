关于ElementUI 和 Element-Plus 中 input 组件的使用区别
ElementUI 修改背景颜色  .Maclass >>> .el-input__inner { background : color }
Element-Plus 修改背景颜色 :deep(.el-input__wrapper) { background : color }
[Waring] the >>> and /deep/ combinators have been deprecated. use :deep() instead.  Vue3 使用:deep()做深度选择

<script lang="ts" setup></script>中使用路由导航的方法
import { useRouter } from 'vue-router'  //引用
const router = useRouter();
router.push({
    path: '/home'
})     
注： 编程式导航route.push与声明式导航<router-link to=""></router-link>是等价的

ElementUI 与 Element-Plus 的具体组件命名
#大体没有大区别，细微之处需要查看官网，移植十分麻烦
[Waring]ElementUI:<el-submenu> 与 Element-Plus:<el-sub-menu>
[Waring]ElementUI:<i class="el-icon-coin"></i> 与 Element-Plus:<el-icon><location /></el-icon>  icon差异最大，plus还要重新引入

关于ElementPlus中菜单弹出框的宽度调整问题，默认值为200px
特别注意：ElementPlus中上述弹出框的位置挂载在index.html的body下，与<id="app">的位置是并列的
因此在<scope>的影响下，在页面添加的具体样式，如.el-menu--popup{min-width: 155px;}是不会作用到pop窗口的？
同理在index.html的<style>下添加可以作用  ----即全局样式
解决方案：用独特类名（防止全局污染），使用popper-class属性挂载（Element-Plus特性）

2022/8/10
关于Chrome以及Edge自动填写账号密码时，input框出现白色底框的原因
浏览器自动填写账号密码之后，会为input自动添加一个类，在Debug区可以查看 类名[:-internal-autofill-selected] 注意其下内容中的[!import]
因此在本例可以选择如下解决办法：
:deep(.el-input :-internal-autofill-selected){
    -webkit-text-fill-color: #fff !important;
    transition: background-color 5000s ease-in-out 0s !important;
    box-shadow: none;
}
新问题：Elment-Plus不能完全响应以上修改，最后input框会出现白色边框，白色边框的修改如下：
:deep(.el-input__wrapper) {
    box-shadow: none;
}
不是边框的宽度，也不是内外边距，试过了所有关于border的设置，最后发现是阴影；
完成input框与背景的纯色融合，想增加交互性可以设置[.el-input__wrapper.is-focus] 和 [.el-input__wrapper:hover]两个属性，具体参考[Login.vue]

[Vue Waring]Invalid event arguments: event validation failed for event "click"
[Vue Waring]Invalid event arguments: event validation failed for event "select"
该警告出现在el-menu中的el-menu-item中，当每个item没有"唯一"标识时会出现以上警告，例如可以为每个item添加index
<el-menu-item index="2-1">game1</el-menu-item>
无效的事件参数:事件“点击”的事件验证失败...

String.replace
replace() 方法返回一个由替换值（replacement）替换部分或所有的模式（pattern）匹配项后的新字符串。
模式可以是一个字符串或者一个正则表达式，替换值可以是一个字符串或者一个每次匹配都要调用的回调函数。
如果pattern是字符串，则仅替换第一个匹配项。
注意返回的是新字符串而且不会修改原字符串。
squaresArray[currentIndex].class.replace("frog"," ") //原值squaresArray[currentIndex].class不会改变
squaresArray[currentIndex].class = squaresArray[currentIndex].class.replace("frog"," ") //需要重新赋值则会改变

v-for可以取整数
<div>
    <span v-for="n in 10">{{ n }} </span>
</div>

Echart的使用
npm安装完后在具体页面   import * as echarts from 'echarts'  全部引入，也可以按需
Echart对dom的绑定要在 onMounted(() => {//Init()}) 中,也就是组件加载完后，否则报错
绑定方法  var myChart = echarts.init(chartDiv.value as HTMLElement);
[Vue Waring]Unhandled error during execution of scheduler flush. This is likely a Vue internals bug.

Echart的更新
在dom更新之后，Echart不会重新渲染，所以需要在 onUpdated(() => {//Init()}) 中重新渲染视图
热更新只会更改dom的属性，Echart的重新渲染还是需要重新加载页面？

Echart按需引入的方法参考
1. 引入echarts核心模块
import * as echarts from 'echarts/core'
2. 引入具体图表组件，后缀都为Chart；引入该图表组件对应的数据格式，后缀为SeriesOption
import {
    ThemeRiverChart,
    ThemeRiverSeriesOption
} from 'echarts/charts';
3. 引入渲染器，CanvasRenderer 或者 SVGRenderer，必须引入其中一个
import {
    CanvasRenderer
} from 'echarts/renderers';
4. 注册使用的组件
echarts.use(
    [SingleAxisComponent, TooltipComponent, LegendComponent, ThemeRiverChart, CanvasRenderer]
);
(TS)5*. TS 组装具体的数据技巧方法，后缀为Option
type EChartsOption = echarts.ComposeOption<
    SingleAxisComponentOption | TooltipComponentOption | LegendComponentOption | ThemeRiverSeriesOption
>